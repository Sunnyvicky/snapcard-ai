<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SnapCard AI - å°ˆæ¥­äººè„ˆç®¡å®¶</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- è¼‰å…¥ Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { background-color: #f8fafc; color: #1e293b; margin: 0; overflow-x: hidden; -webkit-tap-highlight-color: transparent; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, Component } = React;

        // --- éŒ¯èª¤é‚Šç•Œ ---
        class ErrorBoundary extends Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            static getDerivedStateFromError(error) {
                return { hasError: true, error };
            }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="h-screen flex flex-col items-center justify-center p-6 text-center bg-gray-50">
                            <h2 className="text-xl font-bold text-gray-800 mb-2">ç™¼ç”ŸéŒ¯èª¤</h2>
                            <p className="text-sm text-gray-500 mb-4">{this.state.error?.message}</p>
                            <button onClick={() => window.location.reload()} className="bg-blue-600 text-white px-6 py-2 rounded-full">é‡æ–°æ•´ç†</button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        // --- å®‰å…¨çš„ Icon å…ƒä»¶ (é»‘ç›’å­æ¨¡å¼) ---
        // React å»ºç«‹å®¹å™¨ï¼ŒLucide è² è²¬å¡«å…§å®¹ï¼Œäº’ä¸å¹²æ“¾
        const Icon = ({ name, size = 20, className = "" }) => {
            const ref = useRef(null);

            useEffect(() => {
                if (!ref.current || !window.lucide) return;

                // 1. æ¸…ç©ºå®¹å™¨
                const container = ref.current;
                container.innerHTML = '';

                // 2. å»ºç«‹ Lucide éœ€è¦çš„æ¨™ç±¤
                const i = document.createElement('i');
                i.setAttribute('data-lucide', name);
                container.appendChild(i);

                // 3. å‘¼å« Lucide æ¸²æŸ“ï¼Œä¸¦é™åˆ¶ç¯„åœåœ¨ç›®å‰çš„å®¹å™¨å…§
                window.lucide.createIcons({
                    root: container,
                    nameAttr: 'data-lucide',
                    attrs: {
                        width: size,
                        height: size,
                        class: className // å°‡ className å‚³çµ¦ SVG
                    }
                });
            }, [name, size, className]);

            return <span ref={ref} style={{ display: 'inline-flex', alignItems: 'center' }}></span>;
        };

        // --- æ¥µè‡´å®‰å…¨å£“ç¸® (Object URL) ---
        const compressImage = (file) => {
            return new Promise((resolve, reject) => {
                if (!file) return reject("ç„¡æª”æ¡ˆ");
                const url = URL.createObjectURL(file);
                const img = new Image();
                img.src = url;
                img.onload = () => {
                    URL.revokeObjectURL(url);
                    const canvas = document.createElement('canvas');
                    const MAX_SIZE = 600; 
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > MAX_SIZE) {
                            height *= MAX_SIZE / width;
                            width = MAX_SIZE;
                        }
                    } else {
                        if (height > MAX_SIZE) {
                            width *= MAX_SIZE / height;
                            height = MAX_SIZE;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', 0.6)); 
                };
                img.onerror = reject;
            });
        };

        // --- ç›¸æ©Ÿå…ƒä»¶ ---
        const CameraScanner = ({ onCapture, onCancel }) => {
            const videoRef = useRef(null);
            const [error, setError] = useState(null);

            useEffect(() => {
                let stream = null;
                const startCamera = async () => {
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({
                            video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } },
                            audio: false
                        });
                        if (videoRef.current) {
                            videoRef.current.srcObject = stream;
                            videoRef.current.play().catch(e => console.error("Play error", e));
                        }
                    } catch (e) {
                        setError("ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿ: " + e.message);
                    }
                };
                startCamera();
                return () => {
                    if (stream) stream.getTracks().forEach(t => t.stop());
                };
            }, []);

            const capture = () => {
                if (!videoRef.current) return;
                const canvas = document.createElement("canvas");
                canvas.width = videoRef.current.videoWidth;
                canvas.height = videoRef.current.videoHeight;
                canvas.getContext("2d").drawImage(videoRef.current, 0, 0);
                onCapture(canvas.toDataURL("image/jpeg", 0.6));
            };

            return (
                <div className="fixed inset-0 bg-black z-50 flex flex-col">
                    <div className="flex-1 relative overflow-hidden">
                        <video ref={videoRef} playsInline muted autoPlay className="w-full h-full object-cover" />
                        {error && <div className="absolute inset-0 flex items-center justify-center text-white bg-black/80">{error}</div>}
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <div className="w-3/4 aspect-[1.6/1] border-2 border-blue-500 rounded-xl shadow-[0_0_0_999px_rgba(0,0,0,0.5)]"></div>
                        </div>
                    </div>
                    <div className="h-32 bg-black flex items-center justify-center gap-8">
                        <button onClick={onCancel} className="text-white font-bold p-4">å–æ¶ˆ</button>
                        <button onClick={capture} className="w-16 h-16 bg-white rounded-full border-4 border-gray-300"></button>
                        <div className="w-12"></div>
                    </div>
                </div>
            );
        };

        function App() {
            const [view, setView] = useState("home");
            const [cards, setCards] = useState(() => {
                try { return JSON.parse(localStorage.getItem("snapcard_cards") || "[]"); } catch { return []; }
            });
            const [capturedImage, setCapturedImage] = useState(null);
            const [currentAvatar, setCurrentAvatar] = useState(null);
            const [secondImage, setSecondImage] = useState(null); // æ–°å¢ï¼šç¬¬äºŒå¼µç…§ç‰‡
            const [isProcessing, setIsProcessing] = useState(false);
            const [resultData, setResultData] = useState({});
            const [currentCardId, setCurrentCardId] = useState(null);
            const [filterCategory, setFilterCategory] = useState("å…¨éƒ¨");
            const [apiKey, setApiKey] = useState(() => localStorage.getItem("snapcard_api_key") || "");
            const [tempKey, setTempKey] = useState("");
            const [error, setError] = useState(null);
            const avatarInputRef = useRef(null);
            const secondImageInputRef = useRef(null); // æ–°å¢ï¼šç¬¬äºŒå¼µç…§ç‰‡çš„ ref

            useEffect(() => {
                try { localStorage.setItem("snapcard_cards", JSON.stringify(cards)); }
                catch (e) { setError("å„²å­˜ç©ºé–“å·²æ»¿"); }
            }, [cards]);

            const analyze = async (base64) => {
                setIsProcessing(true);
                try {
                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            contents: [{ parts: [
                                { text: `åˆ†æåç‰‡å›å‚³JSON:{"name":"","jobTitle":"","company":"","phone":"","email":"","address":"","category":"å·¥ä½œ","note":""}ã€‚categoryå¾[å·¥ä½œ,å®¶äºº,åŒå­¸,æœ‹å‹]é¸ã€‚noteæ¬„ä½ä¿ç•™ç©ºç™½è®“ä½¿ç”¨è€…å¡«å¯«ã€‚ç„¡Markdownã€‚` },
                                { inlineData: { mimeType: "image/jpeg", data: base64.split(',')[1] } }
                            ] }]
                        })
                    });
                    const json = await res.json();
                    if (json.error) throw new Error(json.error.message);
                    
                    let text = json.candidates[0].content.parts[0].text;
                    text = text.replace(/```json|```/g, '').trim();
                    const start = text.indexOf('{'), end = text.lastIndexOf('}');
                    const data = JSON.parse(text.substring(start, end + 1));
                    
                    setResultData(data || { category: "å·¥ä½œ" });
                    setCapturedImage(base64);
                    setCurrentAvatar(null);
                    setSecondImage(null); // é‡ç½®ç¬¬äºŒå¼µç…§ç‰‡
                    setCurrentCardId(null);
                    setView("result");
                } catch (e) {
                    setError("è¾¨è­˜å¤±æ•—: " + e.message);
                    setView("home");
                } finally {
                    setIsProcessing(false);
                }
            };

            const saveCard = () => {
                const newData = { 
                    id: currentCardId || Date.now(), 
                    ...resultData, 
                    image: capturedImage, 
                    avatar: currentAvatar,
                    secondImage: secondImage, // å„²å­˜ç¬¬äºŒå¼µç…§ç‰‡
                    category: resultData.category || "å·¥ä½œ" 
                };
                
                if (currentCardId) {
                    setCards(cards.map(c => c.id === currentCardId ? newData : c));
                } else {
                    setCards([newData, ...cards]);
                }
                setView("home");
            };

            const handleAvatarUpload = async (e) => {
                if (e.target.files[0]) {
                    try {
                        const base64 = await compressImage(e.target.files[0]);
                        setCurrentAvatar(base64);
                    } catch(err) { alert("åœ–ç‰‡è™•ç†å¤±æ•—"); }
                }
            };

            const handleSecondImageUpload = async (e) => {
                if (e.target.files[0]) {
                    try {
                        const base64 = await compressImage(e.target.files[0]);
                        setSecondImage(base64);
                    } catch(err) { alert("åœ–ç‰‡è™•ç†å¤±æ•—"); }
                }
            };

            const viewSavedCard = (card) => {
                setResultData({...card});
                setCapturedImage(card.image);
                setCurrentAvatar(card.avatar);
                setSecondImage(card.secondImage); // è¼‰å…¥ç¬¬äºŒå¼µç…§ç‰‡
                setCurrentCardId(card.id);
                setView("result");
            };

            const filteredCards = filterCategory === "å…¨éƒ¨" ? cards : cards.filter(c => c.category === filterCategory);

            return (
                <div className="max-w-md mx-auto h-screen bg-gray-50 flex flex-col font-sans overflow-hidden border-x border-gray-200">
                    <header className="px-6 pt-12 pb-4 bg-white shadow-sm flex justify-between items-center z-10">
                        <h1 className="text-xl font-black text-blue-600 tracking-tighter">SNAPCARD</h1>
                        <button onClick={() => setView("settings")} className="text-gray-400">
                            <Icon name="settings" />
                        </button>
                    </header>

                    <main className="flex-1 overflow-y-auto p-4 relative">
                        {error && <div className="bg-red-100 text-red-600 p-3 rounded-lg mb-4 text-xs font-bold">{error}</div>}

                        {view === "home" && (
                            <div className="space-y-4">
                                {!apiKey && (
                                    <div onClick={() => setView("settings")} className="bg-blue-50 p-4 rounded-xl text-blue-600 text-center text-sm font-bold cursor-pointer border border-blue-100 animate-pulse">
                                        ğŸ‘‰ è«‹å…ˆè¨­å®š API Key
                                    </div>
                                )}
                                
                                <div className="flex gap-2 overflow-x-auto pb-2 hide-scrollbar">
                                    {["å…¨éƒ¨", "å·¥ä½œ", "å®¶äºº", "åŒå­¸", "æœ‹å‹"].map(cat => (
                                        <button key={cat} onClick={() => setFilterCategory(cat)} className={`px-4 py-1.5 rounded-full text-xs font-bold whitespace-nowrap transition-colors ${filterCategory === cat ? "bg-blue-600 text-white" : "bg-white text-gray-500 border"}`}>
                                            {cat}
                                        </button>
                                    ))}
                                </div>

                                {filteredCards.length === 0 ? (
                                    <div className="text-center py-20 text-gray-400 text-sm">æš«ç„¡åç‰‡</div>
                                ) : (
                                    filteredCards.map(c => (
                                        <div key={c.id} onClick={() => viewSavedCard(c)} className="bg-white p-4 rounded-xl shadow-sm flex gap-4 items-center cursor-pointer active:scale-95 transition-transform">
                                            <div className="w-12 h-12 bg-gray-100 rounded-lg flex items-center justify-center overflow-hidden border">
                                                {c.avatar ? <img src={c.avatar} className="w-full h-full object-cover" /> : <span className="font-bold text-gray-400">{c.name?.[0]}</span>}
                                            </div>
                                            <div className="flex-1 min-w-0">
                                                <div className="font-bold truncate">{c.name}</div>
                                                <div className="text-xs text-gray-400 truncate">{c.company}</div>
                                            </div>
                                            <button onClick={(e) => { e.stopPropagation(); if(confirm("åˆªé™¤?")) setCards(cards.filter(x => x.id !== c.id)); }} className="text-gray-300 hover:text-red-500">
                                                <Icon name="trash-2" />
                                            </button>
                                        </div>
                                    ))
                                )}
                            </div>
                        )}

                        {view === "settings" && (
                            <div className="p-4 bg-white rounded-xl shadow-sm space-y-4">
                                <h3 className="font-bold">API è¨­å®š</h3>
                                <input className="w-full bg-gray-100 p-2 rounded text-sm" placeholder="è¼¸å…¥ API Key" value={tempKey} onChange={e => setTempKey(e.target.value)} />
                                <button onClick={() => { localStorage.setItem("snapcard_api_key", tempKey); setApiKey(tempKey); setView("home"); }} className="w-full bg-blue-600 text-white p-2 rounded font-bold">å„²å­˜</button>
                                <button onClick={() => { if(confirm("æ¸…ç©º?")) { setCards([]); localStorage.removeItem("snapcard_cards"); } }} className="w-full text-red-500 p-2 text-xs">æ¸…ç©ºæ‰€æœ‰è³‡æ–™</button>
                            </div>
                        )}

                        {view === "result" && (
                            <div className="space-y-4 pb-20">
                                <div className="bg-white p-6 rounded-2xl shadow-lg border-t-4 border-blue-500">
                                    <div className="flex items-center gap-4 mb-6">
                                        <div onClick={() => avatarInputRef.current?.click()} className="w-20 h-20 bg-blue-50 rounded-full flex items-center justify-center overflow-hidden border-4 border-white shadow-md shrink-0 cursor-pointer">
                                            {currentAvatar ? <img src={currentAvatar} className="w-full h-full object-cover" /> : <Icon name="camera" size={32} className="text-blue-300" />}
                                        </div>
                                        <input type="file" ref={avatarInputRef} className="hidden" accept="image/*" onChange={handleAvatarUpload} />
                                        
                                        <div className="flex-1 space-y-2">
                                            <input className="text-xl font-black w-full bg-transparent border-b focus:border-blue-500 outline-none" value={resultData.name || ""} placeholder="å§“å" onChange={e => setResultData({...resultData, name: e.target.value})} />
                                            <input className="text-sm text-blue-500 font-bold w-full bg-transparent border-b focus:border-blue-500 outline-none" value={resultData.jobTitle || ""} placeholder="è·ç¨±" onChange={e => setResultData({...resultData, jobTitle: e.target.value})} />
                                        </div>
                                    </div>

                                    <div className="space-y-3">
                                        <div className="flex items-center gap-3 border-b pb-1">
                                            <Icon name="tag" className="text-gray-400" />
                                            <select className="flex-1 bg-transparent font-bold text-sm outline-none" value={resultData.category || "å·¥ä½œ"} onChange={e => setResultData({...resultData, category: e.target.value})}>
                                                {["å·¥ä½œ", "å®¶äºº", "åŒå­¸", "æœ‹å‹"].map(c => <option key={c} value={c}>{c}</option>)}
                                            </select>
                                        </div>
                                        {[
                                            { icon: "building", key: "company", label: "å…¬å¸" },
                                            { icon: "phone", key: "phone", label: "é›»è©±" },
                                            { icon: "mail", key: "email", label: "Email" },
                                            { icon: "map-pin", key: "address", label: "åœ°å€" }
                                        ].map(f => (
                                            <div key={f.key} className="flex items-center gap-3 border-b pb-1">
                                                <Icon name={f.icon} className="text-gray-400" />
                                                <input className="flex-1 bg-transparent text-sm font-medium outline-none" value={resultData[f.key] || ""} placeholder={f.label} onChange={e => setResultData({...resultData, [f.key]: e.target.value})} />
                                                <Icon name="pencil" size={14} className="text-gray-300" />
                                            </div>
                                        ))}
                                        {/* æ–°å¢ï¼šå‚™è¨»æ¬„ä½ */}
                                        <div className="flex items-start gap-3 border-b pb-1">
                                            <div className="mt-1"><Icon name="file-text" className="text-gray-400" /></div>
                                            <textarea 
                                                className="flex-1 bg-transparent text-sm font-medium outline-none resize-none h-20"
                                                value={resultData.note || ""}
                                                placeholder="å¡«å¯«å‚™è¨»..."
                                                onChange={e => setResultData({...resultData, note: e.target.value})}
                                            />
                                            <div className="mt-1"><Icon name="pencil" size={14} className="text-gray-300" /></div>
                                        </div>
                                    </div>
                                </div>

                                {capturedImage && (
                                    <div className="bg-white p-4 rounded-xl shadow-sm">
                                        <p className="text-xs font-bold text-gray-400 mb-2">åç‰‡å¿«ç…§</p>
                                        <img src={capturedImage} className="w-full rounded-lg" />
                                    </div>
                                )}

                                {/* æ–°å¢ï¼šé™„åŠ ç…§ç‰‡å€å¡Š */}
                                <div className="bg-white p-4 rounded-xl shadow-sm">
                                    <div className="flex justify-between items-center mb-2">
                                        <p className="text-xs font-bold text-gray-400">é™„åŠ ç…§ç‰‡</p>
                                        <button onClick={() => secondImageInputRef.current?.click()} className="text-blue-500 text-xs font-bold">
                                            {secondImage ? "æ›´æ›" : "ä¸Šå‚³"}
                                        </button>
                                    </div>
                                    <input type="file" ref={secondImageInputRef} className="hidden" accept="image/*" onChange={handleSecondImageUpload} />
                                    {secondImage ? (
                                        <img src={secondImage} className="w-full rounded-lg" />
                                    ) : (
                                        <div onClick={() => secondImageInputRef.current?.click()} className="w-full h-32 bg-gray-50 rounded-lg border-2 border-dashed border-gray-200 flex flex-col items-center justify-center text-gray-300 cursor-pointer">
                                            <Icon name="plus" size={24} />
                                            <span className="text-xs mt-1">é»æ“Šä¸Šå‚³</span>
                                        </div>
                                    )}
                                </div>

                                <div className="flex gap-2">
                                    <button onClick={() => setView("home")} className="flex-1 bg-gray-100 text-gray-600 p-3 rounded-xl font-bold">å–æ¶ˆ</button>
                                    <button onClick={saveCard} className="flex-[2] bg-blue-600 text-white p-3 rounded-xl font-bold flex justify-center items-center gap-2">
                                        <Icon name="save" /> å„²å­˜
                                    </button>
                                </div>
                            </div>
                        )}
                    </main>

                    {view === "home" && (
                        <div className="fixed bottom-6 left-0 w-full flex justify-center pointer-events-none">
                            <button onClick={() => apiKey ? setView("scan") : setView("settings")} className="bg-blue-600 text-white w-16 h-16 rounded-full flex items-center justify-center shadow-2xl active:scale-90 transition-transform pointer-events-auto border-4 border-white hover:bg-blue-700">
                                <Icon name="camera" size={32} />
                            </button>
                        </div>
                    )}

                    {view === "scan" && <CameraScanner onCapture={analyze} onCancel={() => setView("home")} />}

                    {isProcessing && (
                        <div className="fixed inset-0 bg-black/80 z-[60] flex flex-col items-center justify-center text-white">
                            <div className="animate-spin w-10 h-10 border-4 border-white border-t-transparent rounded-full mb-4"></div>
                            <p>AI è¾¨è­˜ä¸­...</p>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ErrorBoundary><App /></ErrorBoundary>);
    </script>
</body>
</html>
