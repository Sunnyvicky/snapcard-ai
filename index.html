<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SnapCard AI - å°ˆæ¥­äººè„ˆç®¡å®¶</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- è¼‰å…¥ Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { background-color: #f8fafc; color: #1e293b; margin: 0; overflow-x: hidden; -webkit-tap-highlight-color: transparent; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        /* å¼·åˆ¶å½±ç‰‡æ»¿ç‰ˆä¸”æœ€ä¸Šå±¤ */
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 10;
            transform: scaleX(1); /* ç¢ºä¿å¾Œé¡é ­ä¸é¡åƒ */
        }
        /* æƒæç·šå‹•ç•« */
        @keyframes scan {
            0% { top: 0%; opacity: 0; }
            50% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }
        .scan-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background: #3b82f6;
            box-shadow: 0 0 10px #3b82f6;
            animation: scan 2s linear infinite;
        }
        /* å•Ÿå‹•ç•«é¢æ¨£å¼ */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8fafc;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
    </style>
</head>
<body>
    <!-- 1. å•Ÿå‹•ç•«é¢ï¼šReact è¼‰å…¥å‰é¡¯ç¤ºï¼Œè¼‰å…¥å¾Œè‡ªå‹•æ¶ˆå¤± (ç„¡å»¶é²) -->
    <div id="root">
        <div class="splash-screen">
            <div style="width: 64px; height: 64px; background-color: #2563eb; border-radius: 16px; display: flex; align-items: center; justify-content: center; margin-bottom: 16px; box-shadow: 0 10px 25px -5px rgba(37, 99, 235, 0.4);">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>
            </div>
            <h1 style="font-size: 20px; font-weight: 900; color: #1e293b; font-family: sans-serif; letter-spacing: -0.5px;">SNAPCARD AI</h1>
            <p style="font-size: 14px; color: #64748b; font-family: sans-serif; margin-top: 8px; letter-spacing: 1px;">äººè„ˆï¼Œæ˜¯æœ€å¥½çš„è³‡æº</p>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useMemo, Component } = React;

        // --- IndexedDB è³‡æ–™åº«å·¥å…· ---
        const DB_NAME = 'SnapCardDB';
        const STORE_NAME = 'cards';
        const DB_VERSION = 1;

        const dbUtils = {
            open: () => {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            getAll: async () => {
                const db = await dbUtils.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },
            put: async (card) => {
                const db = await dbUtils.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.put(card);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },
            delete: async (id) => {
                const db = await dbUtils.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            },
            clear: async () => {
                const db = await dbUtils.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.clear();
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        };

        // --- éŒ¯èª¤é‚Šç•Œ ---
        class ErrorBoundary extends Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            static getDerivedStateFromError(error) {
                return { hasError: true, error };
            }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="h-screen flex flex-col items-center justify-center p-6 text-center bg-gray-50">
                            <h2 className="text-xl font-bold text-gray-800 mb-2">ç™¼ç”ŸéŒ¯èª¤</h2>
                            <p className="text-sm text-gray-500 mb-4">{this.state.error?.message}</p>
                            <button onClick={() => window.location.reload()} className="bg-blue-600 text-white px-6 py-2 rounded-full">é‡æ–°æ•´ç†</button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        // --- å®‰å…¨çš„ Icon å…ƒä»¶ ---
        const Icon = ({ name, size = 20, className = "" }) => {
            const ref = useRef(null);

            useEffect(() => {
                if (!ref.current || !window.lucide) return;
                const container = ref.current;
                container.innerHTML = '';
                const i = document.createElement('i');
                i.setAttribute('data-lucide', name);
                container.appendChild(i);
                window.lucide.createIcons({
                    root: container,
                    nameAttr: 'data-lucide',
                    attrs: {
                        width: size,
                        height: size,
                        class: className
                    }
                });
            }, [name, size, className]);

            return <span ref={ref} style={{ display: 'inline-flex', alignItems: 'center' }}></span>;
        };

        // --- æ¥µè‡´å®‰å…¨å£“ç¸® (Object URL) ---
        const compressImage = (file) => {
            return new Promise((resolve, reject) => {
                if (!file) return reject("ç„¡æª”æ¡ˆ");
                const url = URL.createObjectURL(file);
                const img = new Image();
                img.src = url;
                img.onload = () => {
                    URL.revokeObjectURL(url);
                    const canvas = document.createElement('canvas');
                    const MAX_SIZE = 800; 
                    let width = img.width;
                    let height = img.height;

                    if (width > height) {
                        if (width > MAX_SIZE) {
                            height *= MAX_SIZE / width;
                            width = MAX_SIZE;
                        }
                    } else {
                        if (height > MAX_SIZE) {
                            width *= MAX_SIZE / height;
                            height = MAX_SIZE;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', 0.6)); 
                };
                img.onerror = reject;
            });
        };

        // --- ç›¸æ©Ÿå…ƒä»¶ (WYSIWYG è£åˆ‡ç‰ˆ) ---
        const CameraScanner = ({ onCapture, onCancel }) => {
            const videoRef = useRef(null);
            const [error, setError] = useState(null);

            useEffect(() => {
                let stream = null;
                const startCamera = async () => {
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({
                            video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } },
                            audio: false
                        });
                        if (videoRef.current) {
                            videoRef.current.srcObject = stream;
                            videoRef.current.play().catch(e => console.error("Play error", e));
                        }
                    } catch (e) {
                        setError("ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿ: " + e.message);
                    }
                };
                startCamera();
                return () => {
                    if (stream) stream.getTracks().forEach(t => t.stop());
                };
            }, []);

            const capture = () => {
                if (!videoRef.current) return;
                const video = videoRef.current;
                const canvas = document.createElement("canvas");
                
                const videoRatio = video.videoWidth / video.videoHeight;
                const displayRatio = video.clientWidth / video.clientHeight;
                
                let sx = 0, sy = 0, sWidth = video.videoWidth, sHeight = video.videoHeight;

                if (videoRatio > displayRatio) {
                    sWidth = video.videoHeight * displayRatio;
                    sx = (video.videoWidth - sWidth) / 2;
                } else {
                    sHeight = video.videoWidth / displayRatio;
                    sy = (video.videoHeight - sHeight) / 2;
                }

                const MAX_DIM = 1000;
                let destWidth = sWidth;
                let destHeight = sHeight;
                
                if (destWidth > MAX_DIM || destHeight > MAX_DIM) {
                    const scale = Math.min(MAX_DIM / destWidth, MAX_DIM / destHeight);
                    destWidth *= scale;
                    destHeight *= scale;
                }

                canvas.width = destWidth;
                canvas.height = destHeight;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, destWidth, destHeight);
                
                onCapture(canvas.toDataURL("image/jpeg", 0.7));
            };

            return (
                <div className="fixed inset-0 bg-black z-50 flex flex-col">
                    <div className="flex-1 relative overflow-hidden">
                        <video ref={videoRef} playsInline muted autoPlay className="w-full h-full object-cover" />
                        {error && <div className="absolute inset-0 flex items-center justify-center text-white bg-black/80">{error}</div>}
                        
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-20">
                            <div className="w-3/4 aspect-[1.6/1] border-2 border-blue-500 rounded-xl relative shadow-[0_0_0_999px_rgba(0,0,0,0.5)] overflow-hidden">
                                <div className="scan-line"></div>
                                <div className="absolute top-0 left-0 w-4 h-4 border-t-4 border-l-4 border-blue-500 -mt-1 -ml-1"></div>
                                <div className="absolute top-0 right-0 w-4 h-4 border-t-4 border-r-4 border-blue-500 -mt-1 -mr-1"></div>
                                <div className="absolute bottom-0 left-0 w-4 h-4 border-b-4 border-l-4 border-blue-500 -mb-1 -ml-1"></div>
                                <div className="absolute bottom-0 right-0 w-4 h-4 border-b-4 border-r-4 border-blue-500 -mb-1 -mr-1"></div>
                            </div>
                        </div>
                        <div className="absolute bottom-32 w-full text-center z-20">
                            <span className="px-4 py-2 bg-black/50 text-white text-xs rounded-full">è«‹å°‡åç‰‡æ”¾å…¥æ¡†å…§</span>
                        </div>
                    </div>
                    <div className="h-32 bg-black flex items-center justify-center gap-8 z-30">
                        <button onClick={onCancel} className="text-white font-bold p-4">å–æ¶ˆ</button>
                        <button onClick={capture} className="w-16 h-16 bg-white rounded-full border-4 border-gray-300 active:scale-95 transition-transform"></button>
                        <div className="w-12"></div>
                    </div>
                </div>
            );
        };

        function App() {
            const [view, setView] = useState("home");
            const [cards, setCards] = useState([]);
            const [isLoadingDB, setIsLoadingDB] = useState(true);
            
            const [capturedImage, setCapturedImage] = useState(null); 
            const [backImage, setBackImage] = useState(null); 
            const [currentAvatar, setCurrentAvatar] = useState(null);
            const [additionalImage, setAdditionalImage] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);
            const [resultData, setResultData] = useState({});
            const [currentCardId, setCurrentCardId] = useState(null);
            const [filterCategory, setFilterCategory] = useState("å…¨éƒ¨");
            const [apiKey, setApiKey] = useState(() => localStorage.getItem("snapcard_api_key") || "");
            const [tempKey, setTempKey] = useState("");
            const [error, setError] = useState(null);
            const [statusMsg, setStatusMsg] = useState("AI è¾¨è­˜ä¸­...");
            const avatarInputRef = useRef(null);
            const secondImageInputRef = useRef(null); 
            const [searchQuery, setSearchQuery] = useState(""); 
            const importFileRef = useRef(null); 

            // åˆå§‹åŒ–æ™‚è®€å– IndexedDB (å„ªåŒ–ç‰ˆï¼šåªé·ç§»ä¸€æ¬¡)
            useEffect(() => {
                const loadCards = async () => {
                    try {
                        setIsLoadingDB(true);
                        const dbCards = await dbUtils.getAll();
                        
                        // æª¢æŸ¥æ˜¯å¦å·²é·ç§»é
                        const hasMigrated = localStorage.getItem("snapcard_migrated");
                        const localCardsStr = localStorage.getItem("snapcard_cards");

                        if (localCardsStr && !hasMigrated) {
                            try {
                                const localCards = JSON.parse(localCardsStr);
                                if (localCards.length > 0) {
                                    console.log("Migrating data from LocalStorage to IndexedDB...");
                                    for (const card of localCards) {
                                        if (!dbCards.find(c => c.id === card.id)) {
                                            await dbUtils.put(card);
                                            dbCards.push(card);
                                        }
                                    }
                                    localStorage.setItem("snapcard_migrated", "true");
                                }
                            } catch (e) {
                                console.error("Migration error", e);
                            }
                        }
                        
                        setCards(dbCards.sort((a, b) => b.id - a.id));
                    } catch (err) {
                        console.error("DB Load Error", err);
                        setError("è³‡æ–™åº«è®€å–å¤±æ•—");
                    } finally {
                        setIsLoadingDB(false);
                    }
                };
                loadCards();
            }, []);

            useEffect(() => {
                const timer = setTimeout(() => {
                    if (window.lucide) window.lucide.createIcons();
                }, 50);
                return () => clearTimeout(timer);
            }, [view, cards.length, resultData, additionalImage, backImage, currentAvatar, filterCategory]);

            const startScanFlow = () => {
                if (!apiKey) {
                    setView("settings");
                    return;
                }
                setTempScans([]);
                setView("scan");
            };

            // æ‰‹å‹•æ–°å¢åŠŸèƒ½
            const handleManualAdd = () => {
                setResultData({ category: "å·¥ä½œ" });
                setCapturedImage(null);
                setBackImage(null);
                setCurrentAvatar(null);
                setAdditionalImage(null);
                setCurrentCardId(null);
                setView("result");
            };

            const handleScanCapture = (base64) => {
                setCapturedImage(base64);
                analyze(base64);
            };

            const analyze = async (base64) => {
                setIsProcessing(true);
                setError(null);
                
                const models = [
                    "gemini-2.0-flash-exp", 
                    "gemini-2.5-flash-preview-09-2025"
                ];

                let imageParts = [{
                    inlineData: { mimeType: "image/jpeg", data: base64.split(',')[1] }
                }];

                const promptText = `åˆ†æåç‰‡å›å‚³JSON:{"name":"","jobTitle":"","company":"","mobile":"","tel":"","fax":"","email":"","address":"","category":"å·¥ä½œ","note":""}ã€‚
                é‡é»è¦å‰‡ï¼š
                1. è«‹å°‡é›»è©±å€åˆ†ç‚º mobile(æ‰‹æ©Ÿ), tel(å¸‚è©±), fax(å‚³çœŸ)ã€‚
                2. companyæ¬„ä½è«‹åˆä½µä¸­æ–‡åŠè‹±æ–‡åç¨±ã€‚
                3. categoryå¾[å·¥ä½œ,å®¶äºº,åŒå­¸,æœ‹å‹]é¸ã€‚
                4. noteæ¬„ä½ä¿ç•™ç©ºç™½ã€‚
                ç„¡Markdownã€‚`;

                const tryModel = async (index) => {
                    if (index >= models.length) {
                        throw new Error("ç³»çµ±å¿™ç·šä¸­ (429)ï¼Œè«‹ä¼‘æ¯ 1 åˆ†é˜å¾Œå†è©¦ã€‚");
                    }
                    const model = models[index];
                    setStatusMsg(index === 0 ? "AI è¾¨è­˜ä¸­..." : "åˆ‡æ›å‚™ç”¨ç·šè·¯...");
                    
                    try {
                        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                contents: [{ 
                                    parts: [
                                        { text: promptText },
                                        ...imageParts
                                    ] 
                                }]
                            })
                        });

                        if (!res.ok) {
                            if ([404, 429, 500, 503].includes(res.status)) {
                                console.warn(`Model ${model} failed (${res.status}), trying next...`);
                                return await tryModel(index + 1);
                            }
                            const errJson = await res.json().catch(() => ({}));
                            throw new Error(errJson.error?.message || `API Error (${res.status})`);
                        }

                        return await res.json();
                    } catch (e) {
                        return await tryModel(index + 1);
                    }
                };

                try {
                    const json = await tryModel(0);
                    
                    let text = json.candidates[0].content.parts[0].text;
                    text = text.replace(/```json|```/g, '').trim();
                    const start = text.indexOf('{'), end = text.lastIndexOf('}');
                    const data = JSON.parse(text.substring(start, end + 1));
                    
                    setResultData(data || { category: "å·¥ä½œ" });
                    
                    setBackImage(null);
                    setAdditionalImage(null);
                    setCurrentAvatar(null);
                    setCurrentCardId(null);
                    setView("result");
                } catch (e) {
                    setError(e.message);
                    setView("home");
                } finally {
                    setIsProcessing(false);
                }
            };

            // æ”¹å¯«å„²å­˜åŠŸèƒ½ï¼šä½¿ç”¨ IndexedDB
            const saveCard = async () => {
                const newData = { 
                    id: currentCardId || Date.now(), 
                    ...resultData, 
                    image: capturedImage, 
                    backImage: backImage, 
                    avatar: currentAvatar,
                    additionalImage: additionalImage, 
                    category: resultData.category || "å·¥ä½œ" 
                };
                
                try {
                    await dbUtils.put(newData);
                    
                    if (currentCardId) {
                        setCards(prev => prev.map(c => c.id === currentCardId ? newData : c));
                    } else {
                        setCards(prev => [newData, ...prev]);
                    }
                    setView("home");
                } catch (e) {
                    alert("å„²å­˜å¤±æ•—: " + e.message);
                }
            };

            const handleDeleteCard = async (id, e) => {
                e.stopPropagation();
                if(confirm("ç¢ºå®šè¦åˆªé™¤é€™å¼µåç‰‡å—ï¼Ÿ")) {
                    try {
                        await dbUtils.delete(id);
                        setCards(prev => prev.filter(c => c.id !== id));
                    } catch (e) {
                        alert("åˆªé™¤å¤±æ•—");
                    }
                }
            };

            const handleAvatarUpload = async (e) => {
                if (e.target.files[0]) {
                    try {
                        const base64 = await compressImage(e.target.files[0]);
                        setCurrentAvatar(base64);
                    } catch(err) { alert("åœ–ç‰‡è™•ç†å¤±æ•—"); }
                }
            };

            const handleSecondImageUpload = async (e) => {
                if (e.target.files[0]) {
                    try {
                        const base64 = await compressImage(e.target.files[0]);
                        setAdditionalImage(base64);
                    } catch(err) { alert("åœ–ç‰‡è™•ç†å¤±æ•—"); }
                }
            };

            const viewSavedCard = (card) => {
                const data = {...card};
                if (data.phone && !data.mobile && !data.tel) {
                    if (data.phone.startsWith("09")) data.mobile = data.phone;
                    else data.tel = data.phone;
                }

                setResultData(data);
                setCapturedImage(card.image);
                setBackImage(card.backImage || null);
                setCurrentAvatar(card.avatar);
                setAdditionalImage(card.additionalImage || null); 
                setCurrentCardId(card.id);
                setView("result");
            };

            const filteredCards = useMemo(() => {
                let result = filterCategory === "å…¨éƒ¨" ? cards : cards.filter(c => c.category === filterCategory);
                if (searchQuery) {
                    const q = searchQuery.toLowerCase();
                    result = result.filter(c => 
                        (c.name && c.name.toLowerCase().includes(q)) || 
                        (c.company && c.company.toLowerCase().includes(q))
                    );
                }
                return result.sort((a, b) => {
                    const companyA = (a.company || "").toLowerCase();
                    const companyB = (b.company || "").toLowerCase();
                    return companyA.localeCompare(companyB, "zh-Hant");
                });
            }, [cards, filterCategory, searchQuery]);

            // æš«å­˜è®Šæ•¸
            const [tempScans, setTempScans] = useState([]); 

            // åŒ¯å‡ºè³‡æ–™ (ä¿®æ­£ç‰ˆï¼šæ”¯æ´ Blob ä¸‹è¼‰, å¼·åˆ¶ä¸‹è¼‰, å¢åŠ  alert)
            const exportData = () => {
                if (cards.length === 0) {
                    alert("ç›®å‰æ²’æœ‰åç‰‡è³‡æ–™å¯ä¾›åŒ¯å‡º");
                    return;
                }
                const dataStr = JSON.stringify(cards, null, 2);
                // é—œéµï¼šä½¿ç”¨ octet-stream å¼·åˆ¶ç€è¦½å™¨ä¸‹è¼‰ï¼Œé¿å…ç›´æ¥é–‹å•Ÿ
                const blob = new Blob([dataStr], { type: "application/octet-stream" });
                const url = URL.createObjectURL(blob);
                
                const exportFileDefaultName = `snapcard_backup_${new Date().toISOString().slice(0,10)}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.style.display = "none";
                linkElement.href = url;
                linkElement.download = exportFileDefaultName;
                
                document.body.appendChild(linkElement);
                linkElement.click();
                
                setTimeout(() => {
                    document.body.removeChild(linkElement);
                    window.URL.revokeObjectURL(url);
                    // å¢åŠ æç¤ºï¼Œè®“ä½¿ç”¨è€…çŸ¥é“å‹•ä½œå·²è§¸ç™¼
                    alert(`å·²å»ºç«‹å‚™ä»½æª”ï¼š${exportFileDefaultName}\nè«‹æª¢æŸ¥æ‚¨çš„ä¸‹è¼‰è³‡æ–™å¤¾ã€‚`);
                }, 100);
            };

            // åŒ¯å…¥è³‡æ–™ (å¯«å…¥ IndexedDB)
            const importData = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const fileReader = new FileReader();
                fileReader.readAsText(file, "UTF-8");
                fileReader.onload = async e => {
                    try {
                        const importedCards = JSON.parse(e.target.result);
                        if (Array.isArray(importedCards)) {
                            if (confirm(`ç¢ºå®šåŒ¯å…¥ ${importedCards.length} ç­†åç‰‡è³‡æ–™ï¼Ÿ`)) {
                                for (const card of importedCards) {
                                    await dbUtils.put(card);
                                }
                                const allCards = await dbUtils.getAll();
                                setCards(allCards.sort((a, b) => b.id - a.id));
                                alert("åŒ¯å…¥æˆåŠŸï¼");
                            }
                        } else {
                            alert("æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼šè«‹é¸æ“‡æ­£ç¢ºçš„å‚™ä»½æª”");
                        }
                    } catch (err) {
                        alert("è®€å–å‚™ä»½æª”å¤±æ•—");
                    }
                };
                e.target.value = '';
            };

            // æ¸…ç©ºæ‰€æœ‰è³‡æ–™
            const clearAllData = async () => {
                if(confirm("è­¦å‘Šï¼šé€™å°‡åˆªé™¤æ‰€æœ‰è³‡æ–™ã€‚ç¢ºå®šå—ï¼Ÿ")) {
                    try {
                        await dbUtils.clear();
                        setCards([]);
                        localStorage.removeItem("snapcard_cards"); // æ¸…é™¤èˆŠéºç•™
                        alert("è³‡æ–™å·²æ¸…ç©º");
                    } catch (e) {
                        alert("æ¸…é™¤å¤±æ•—");
                    }
                }
            };

            return (
                <div className="max-w-md mx-auto h-screen bg-gray-50 flex flex-col font-sans overflow-hidden border-x border-gray-200">
                    <header className="px-6 pt-12 pb-4 bg-white shadow-sm flex justify-between items-center z-10">
                        <h1 className="text-xl font-black text-blue-600 tracking-tighter">SNAPCARD</h1>
                        <button onClick={() => setView("settings")} className="text-gray-400">
                            <Icon name="settings" />
                        </button>
                    </header>

                    <main className="flex-1 overflow-y-auto p-4 relative">
                        {error && <div className="bg-red-100 text-red-600 p-3 rounded-lg mb-4 text-xs font-bold">{error}</div>}

                        {view === "home" && (
                            <div className="space-y-4">
                                {!apiKey && (
                                    <div onClick={() => setView("settings")} className="bg-blue-50 p-4 rounded-xl text-blue-600 text-center text-sm font-bold cursor-pointer border border-blue-100 animate-pulse">
                                        ğŸ‘‰ è«‹å…ˆè¨­å®š API Key
                                    </div>
                                )}
                                
                                {/* æœå°‹åˆ— */}
                                <div className="relative">
                                    <div className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-400">
                                        <Icon name="search" size={16} />
                                    </div>
                                    <input 
                                        type="text" 
                                        placeholder="æœå°‹å§“åæˆ–å…¬å¸..." 
                                        className="w-full bg-white border border-gray-100 rounded-xl pl-10 pr-4 py-3 text-sm focus:outline-none focus:ring-2 focus:ring-blue-100 shadow-sm"
                                        value={searchQuery}
                                        onChange={(e) => setSearchQuery(e.target.value)}
                                    />
                                    {searchQuery && (
                                        <button onClick={() => setSearchQuery("")} className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-400 p-1">
                                            <Icon name="x" size={14} />
                                        </button>
                                    )}
                                </div>

                                <div className="flex gap-2 overflow-x-auto pb-2 hide-scrollbar">
                                    {["å…¨éƒ¨", "å·¥ä½œ", "å®¶äºº", "åŒå­¸", "æœ‹å‹"].map(cat => (
                                        <button key={cat} onClick={() => setFilterCategory(cat)} className={`px-4 py-1.5 rounded-full text-xs font-bold whitespace-nowrap transition-colors ${filterCategory === cat ? "bg-blue-600 text-white shadow-sm" : "bg-white text-gray-500 border border-gray-100"}`}>
                                            {cat}
                                        </button>
                                    ))}
                                </div>

                                {isLoadingDB ? (
                                    <div className="text-center py-10 text-gray-400">è¼‰å…¥è³‡æ–™ä¸­...</div>
                                ) : filteredCards.length === 0 ? (
                                    <div className="text-center py-20 text-gray-400 text-sm">
                                        {cards.length === 0 ? "æš«ç„¡åç‰‡" : "æ‰¾ä¸åˆ°ç¬¦åˆçš„åç‰‡"}
                                    </div>
                                ) : (
                                    filteredCards.map(c => (
                                        <div key={c.id} onClick={() => viewSavedCard(c)} className="bg-white p-4 rounded-xl shadow-sm flex gap-4 items-center cursor-pointer active:scale-95 transition-transform border border-transparent hover:border-blue-100">
                                            <div className="w-12 h-12 bg-gray-100 rounded-lg flex items-center justify-center overflow-hidden border shrink-0">
                                                {c.avatar ? <img src={c.avatar} className="w-full h-full object-cover" /> : <span className="font-bold text-gray-400">{c.name?.[0]}</span>}
                                            </div>
                                            <div className="flex-1 min-w-0">
                                                {/* ä¿®æ”¹ï¼šå§“å (text-lg ç²—é«” é»‘) */}
                                                <div className="font-bold text-gray-900 text-lg truncate">{c.name || "æœªå¡«å¯«å§“å"}</div>
                                                {/* ä¿®æ”¹ï¼šå…¬å¸ (text-sm ç°è‰²) */}
                                                <div className="text-sm text-gray-500 truncate">{c.company || "æœªå¡«å¯«å…¬å¸"}</div>
                                            </div>
                                            <button onClick={(e) => handleDeleteCard(c.id, e)} className="text-gray-300 hover:text-red-500">
                                                <Icon name="trash-2" />
                                            </button>
                                        </div>
                                    ))
                                )}
                            </div>
                        )}

                        {view === "settings" && (
                            <div className="p-4 bg-white rounded-xl shadow-sm space-y-4">
                                <h3 className="font-bold">API è¨­å®š</h3>
                                <input className="w-full bg-gray-100 p-2 rounded text-sm" placeholder="è¼¸å…¥ API Key" value={tempKey} onChange={e => setTempKey(e.target.value)} />
                                <button onClick={() => { localStorage.setItem("snapcard_api_key", tempKey); setApiKey(tempKey); setView("home"); }} className="w-full bg-blue-600 text-white p-2 rounded font-bold">å„²å­˜</button>
                                
                                <div className="border-t pt-4">
                                    <h3 className="font-bold mb-2">è³‡æ–™ç®¡ç†</h3>
                                    <div className="flex gap-2 mb-4">
                                        {/* ä¿®æ­£ï¼šäº¤æ›åœ–ç¤ºä¸¦å„ªåŒ–æ¨£å¼ */}
                                        <button onClick={exportData} className="flex-1 bg-green-500 text-white p-2 rounded text-sm font-bold flex items-center justify-center gap-1">
                                            <Icon name="upload" size={14} /> åŒ¯å‡ºå‚™ä»½
                                        </button>
                                        <button onClick={() => importFileRef.current.click()} className="flex-1 bg-orange-400 text-white p-2 rounded text-sm font-bold flex items-center justify-center gap-1">
                                            <Icon name="download" size={14} /> åŒ¯å…¥é‚„åŸ
                                        </button>
                                        <input type="file" ref={importFileRef} className="hidden" accept=".json" onChange={importData} />
                                    </div>
                                    <button onClick={clearAllData} className="w-full text-red-500 p-2 text-xs border border-red-200 rounded">æ¸…ç©ºæ‰€æœ‰è³‡æ–™</button>
                                </div>
                            </div>
                        )}

                        {view === "check_scans" && (
                            <div className="h-full flex flex-col p-4 space-y-4">
                                <div className="flex-1 overflow-y-auto space-y-4">
                                    <h2 className="text-lg font-bold text-center">å·²æ‹æ” {tempScans.length} å¼µ</h2>
                                    <div className="grid grid-cols-1 gap-4">
                                        {tempScans.map((img, idx) => (
                                            <div key={idx} className="relative rounded-xl overflow-hidden border shadow-sm">
                                                <img src={img} className="w-full" />
                                                <span className="absolute top-2 left-2 bg-black/60 text-white text-xs px-2 py-1 rounded">
                                                    {idx === 0 ? "æ­£é¢" : "èƒŒé¢"}
                                                </span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                                <div className="flex flex-col gap-3">
                                    {tempScans.length < 2 && (
                                        <button onClick={() => setView("scan")} className="w-full bg-gray-100 text-gray-700 py-3 rounded-xl font-bold flex items-center justify-center gap-2">
                                            <Icon name="camera" size={18} /> ç¹¼çºŒæ‹æ”èƒŒé¢
                                        </button>
                                    )}
                                    <button onClick={() => analyze()} className="w-full bg-blue-600 text-white py-3 rounded-xl font-bold flex items-center justify-center gap-2">
                                        <Icon name="sparkles" size={18} /> é–‹å§‹è¾¨è­˜
                                    </button>
                                    <button onClick={() => { setTempScans([]); setView("home"); }} className="text-gray-400 text-sm py-2">å–æ¶ˆ</button>
                                </div>
                            </div>
                        )}

                        {view === "result" && (
                            <div className="space-y-4 pb-20">
                                <div className="bg-white p-6 rounded-2xl shadow-lg border-t-4 border-blue-500">
                                    <div className="flex items-center gap-4 mb-6">
                                        <div className="relative">
                                            <div onClick={() => avatarInputRef.current?.click()} className="w-20 h-20 bg-blue-50 rounded-full flex items-center justify-center overflow-hidden border-4 border-white shadow-md shrink-0 cursor-pointer">
                                                {currentAvatar ? <img src={currentAvatar} className="w-full h-full object-cover" /> : <Icon name="camera" size={32} className="text-blue-300" />}
                                            </div>
                                            {currentAvatar && <button onClick={(e) => { e.stopPropagation(); setCurrentAvatar(null); }} className="absolute -bottom-1 -right-1 bg-red-500 text-white p-1 rounded-full shadow-md hover:bg-red-600"><Icon name="x" size={12} /></button>}
                                        </div>
                                        <input type="file" ref={avatarInputRef} className="hidden" accept="image/*" onChange={handleAvatarUpload} />
                                        
                                        <div className="flex-1 space-y-2">
                                            <input className="text-xl font-black w-full bg-transparent border-b focus:border-blue-500 outline-none" value={resultData.name || ""} placeholder="å§“å" onChange={e => setResultData({...resultData, name: e.target.value})} />
                                            <input className="text-sm text-blue-500 font-bold w-full bg-transparent border-b focus:border-blue-500 outline-none" value={resultData.jobTitle || ""} placeholder="è·ç¨±" onChange={e => setResultData({...resultData, jobTitle: e.target.value})} />
                                        </div>
                                    </div>

                                    <div className="space-y-3">
                                        <div className="flex items-center gap-3 border-b pb-1">
                                            <Icon name="tag" className="text-gray-400" />
                                            <select className="flex-1 bg-transparent font-bold text-sm outline-none" value={resultData.category || "å·¥ä½œ"} onChange={e => setResultData({...resultData, category: e.target.value})}>
                                                {["å·¥ä½œ", "å®¶äºº", "åŒå­¸", "æœ‹å‹"].map(c => <option key={c} value={c}>{c}</option>)}
                                            </select>
                                        </div>
                                        
                                        {/* æ–°å¢æ’¥è™Ÿèˆ‡å¯„ä¿¡æŒ‰éˆ•ï¼Œæ¢å¾©è©³ç´°åˆ—è¡¨ */}
                                        {[
                                            { icon: "building", key: "company", label: "å…¬å¸" },
                                            { icon: "smartphone", key: "mobile", label: "æ‰‹æ©Ÿ", type: "tel", color: "text-green-500 bg-green-50" },
                                            { icon: "mail", key: "email", label: "Email", type: "mailto", color: "text-blue-500 bg-blue-50" },
                                            { icon: "phone", key: "tel", label: "å¸‚è©±", type: "tel", color: "text-green-500 bg-green-50" },
                                            { icon: "printer", key: "fax", label: "å‚³çœŸ" },
                                            { icon: "map-pin", key: "address", label: "åœ°å€", type: "map", color: "text-red-500 bg-red-50" }
                                        ].map(f => (
                                            <div key={f.key} className="flex items-center gap-3 border-b pb-1">
                                                <Icon name={f.icon} className="text-gray-400" />
                                                <input 
                                                    className="flex-1 bg-transparent text-sm font-medium outline-none" 
                                                    value={resultData[f.key] || ""} 
                                                    placeholder={f.label} 
                                                    onChange={e => setResultData({...resultData, [f.key]: e.target.value})} 
                                                />
                                                {/* åˆ¤æ–·æ˜¯å¦é¡¯ç¤ºå‹•ä½œæŒ‰éˆ• */}
                                                {f.type && resultData[f.key] ? (
                                                    <a 
                                                        href={f.type === 'map' ? `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(resultData[f.key])}` : `${f.type}:${resultData[f.key]}`}
                                                        target={f.type === 'map' ? "_blank" : undefined}
                                                        className={`p-1.5 rounded-full ${f.color} hover:opacity-80 transition-opacity`}
                                                    >
                                                        <Icon name={f.type === 'mailto' ? 'send' : (f.type === 'map' ? 'map' : 'phone')} size={14} />
                                                    </a>
                                                ) : (
                                                    <Icon name="pencil" size={14} className="text-gray-300" />
                                                )}
                                            </div>
                                        ))}
                                        
                                        <div className="flex items-start gap-3 border-b pb-1">
                                            <div className="mt-1"><Icon name="file-text" className="text-gray-400" /></div>
                                            <textarea 
                                                className="flex-1 bg-transparent text-sm font-medium outline-none resize-none h-20"
                                                value={resultData.note || ""}
                                                placeholder="å¡«å¯«å‚™è¨»..."
                                                onChange={e => setResultData({...resultData, note: e.target.value})}
                                            />
                                            <div className="mt-1"><Icon name="pencil" size={14} className="text-gray-300" /></div>
                                        </div>
                                    </div>
                                </div>

                                {/* åç‰‡å¿«ç…§ */}
                                <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-100">
                                    <p className="text-xs font-bold text-gray-400 mb-2 flex items-center gap-2">
                                        <Icon name="image" size={14} /> åç‰‡å¿«ç…§
                                    </p>
                                    <div className="space-y-4">
                                        {capturedImage && (
                                            <div className="relative">
                                                <img src={capturedImage} className="w-full rounded-lg border border-gray-100" />
                                                <span className="absolute top-2 left-2 bg-black/60 text-white text-[10px] px-2 py-0.5 rounded">æ­£é¢</span>
                                            </div>
                                        )}
                                        {backImage && (
                                            <div className="relative">
                                                <img src={backImage} className="w-full rounded-lg border border-gray-100" />
                                                <span className="absolute top-2 left-2 bg-black/60 text-white text-[10px] px-2 py-0.5 rounded">èƒŒé¢</span>
                                            </div>
                                        )}
                                    </div>
                                </div>

                                {/* é™„åŠ ç…§ç‰‡ */}
                                <div className="bg-white p-4 rounded-xl shadow-sm">
                                    <div className="flex justify-between items-center mb-2">
                                        <p className="text-xs font-bold text-gray-400">é™„åŠ ç…§ç‰‡</p>
                                        <div className="flex gap-2">
                                            {additionalImage && (
                                                <button onClick={() => setAdditionalImage(null)} className="text-red-400 text-xs font-bold flex items-center gap-1">
                                                    <Icon name="trash-2" size={14} /> åˆªé™¤
                                                </button>
                                            )}
                                            <button onClick={() => secondImageInputRef.current?.click()} className="text-blue-500 text-xs font-bold flex items-center gap-1">
                                                <Icon name="image-plus" size={14} /> {additionalImage ? "æ›´æ›" : "ä¸Šå‚³"}
                                            </button>
                                        </div>
                                    </div>
                                    <input type="file" ref={secondImageInputRef} className="hidden" accept="image/*" onChange={handleSecondImageUpload} />
                                    {additionalImage ? (
                                        <div className="relative">
                                            <img src={additionalImage} className="w-full rounded-lg border border-gray-100" />
                                            <button onClick={() => setAdditionalImage(null)} className="absolute top-2 right-2 bg-red-500 text-white p-1.5 rounded-full shadow-md border-2 border-white hover:bg-red-600">
                                                <Icon name="trash-2" size={14} />
                                            </button>
                                        </div>
                                    ) : (
                                        <div onClick={() => secondImageInputRef.current?.click()} className="w-full h-32 bg-gray-50 rounded-lg border-2 border-dashed border-gray-200 flex flex-col items-center justify-center text-gray-300 cursor-pointer hover:bg-gray-100 transition-colors">
                                            <Icon name="plus" size={24} />
                                            <span className="text-xs mt-1">é»æ“Šä¸Šå‚³</span>
                                        </div>
                                    )}
                                </div>

                                <div className="flex gap-2">
                                    <button onClick={() => setView("home")} className="flex-1 bg-gray-100 text-gray-600 p-3 rounded-xl font-bold">å–æ¶ˆ</button>
                                    <button onClick={saveCard} className="flex-[2] bg-blue-600 text-white p-3 rounded-xl font-bold flex justify-center items-center gap-2">
                                        <Icon name="save" /> å„²å­˜
                                    </button>
                                </div>
                            </div>
                        )}
                    </main>

                    {view === "home" && (
                        <div className="fixed bottom-6 left-0 w-full flex justify-center pointer-events-none z-20 gap-6 items-end">
                            {/* æ‰‹å‹•è¼¸å…¥æŒ‰éˆ• */}
                            <button 
                                onClick={handleManualAdd}
                                className="bg-gray-700 text-white w-12 h-12 rounded-full flex items-center justify-center shadow-xl active:scale-90 transition-transform pointer-events-auto border-4 border-white hover:bg-gray-600 mb-1"
                            >
                                <Icon name="pencil" size={20} />
                            </button>
                            
                            {/* æƒææŒ‰éˆ• */}
                            <button 
                                onClick={startScanFlow} 
                                className="bg-blue-600 text-white w-16 h-16 rounded-full flex items-center justify-center shadow-2xl active:scale-90 transition-transform pointer-events-auto border-4 border-white hover:bg-blue-700"
                            >
                                <Icon name="camera" size={32} />
                            </button>
                            
                            {/* ä½”ä½ï¼Œä¿æŒå¹³è¡¡ */}
                            <div className="w-12"></div>
                        </div>
                    )}

                    {view === "scan" && <CameraScanner onCapture={handleScanCapture} onCancel={() => { 
                        if(tempScans.length > 0) setView("check_scans");
                        else setView("home"); 
                    }} />}

                    {isProcessing && (
                        <div className="fixed inset-0 bg-black/80 z-[60] flex flex-col items-center justify-center text-white">
                            <div className="animate-spin w-10 h-10 border-4 border-white border-t-transparent rounded-full mb-4"></div>
                            <p>{statusMsg}</p>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ErrorBoundary><App /></ErrorBoundary>);
        setTimeout(() => lucide.createIcons(), 500);
    </script>
</body>
</html>
